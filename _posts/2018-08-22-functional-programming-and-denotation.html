---
layout: post
title: Functional Programming and Denotation Semantic
date: '2018-08-22T15:36:00.000-07:00'
author: daryoush
tags: 
modified_time: '2018-08-27T13:58:01.959-07:00'
thumbnail: https://i.ytimg.com/vi/EI5i54VrAbc/default.jpg
blogger_id: tag:blogger.com,1999:blog-5623577383635787454.post-6224692474840179052
blogger_orig_url: http://onfp.blogspot.com/2018/08/functional-programming-and-denotation.html
---

In  <a href="https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf">The Next 700 Programming Languages</a> paper Peter Ladin define the key feature of functional programming.  He  says:  <blockquote>The commonplace expressions of arithmetic and algebra have a certain simplicity that most communications to computers lack. In particular, (a) each expression has a nesting subexpression structure, (b) each subexpression denotes something (usually a number, truth value or numerical function), (c) the thing an expression denotes, i.e., its "value", depends only on the values of its subexpressions, not on other properties of them. It is these properties, and crucially (c), that explains why such expressions are easier to construct and understand. Thus it is (c) that lies behind the evolutionary trend towards "bigger righthand sides" in place of strings of small, explicitly sequenced assignments and jumps. When faced with a new notation that borrows the functional appearance of everyday algebra, it is (c) that gives us a test for whether the notation is genuinely functional or merely masquerading. </blockquote><br/>It all starts with a functional language.  Following lecture shows Denotational Semantic of an expression in Lambda Calculus to Set.  <iframe allowfullscreen="" frameborder="0" height="270" src="https://www.youtube.com/embed/EI5i54VrAbc" width="480"></iframe> <br/>Once the meaning of an expression is knowns we need the meaning of the values that the expression reduces to.  This is where as a designer you define the meaning of the values in your specific domain.    <br/>In the following lecture, Conal Elliot shows how you extend the denotational semantic to values.   He contrasts this approach to the standard imperative API model.   In imperative API the interface is about creating the state, initializing it and defining functions to side effect the state.    <br/>Functional programming, on the other hand, is about APIs to define things that "ARE" in the domain.  There is a clear distinction between values and evaluation.    So you have base values, transformation, and composition operators.   In all, you need to make sure there is a clear, and precise meaning to the values and that it can lead to an efficient implementation.    The distinction is sometimes hard to get.  For me an analogy is SQL.  An SQL expression defines that property of the result your are interested in, the database engine then turns that into an execution plan and evaluates it to give you the results.    <iframe allowfullscreen="" frameborder="0" height="270" src="https://www.youtube.com/embed/teRC_Lf61Gw" width="480"></iframe><br/>The key take away from the talk is that it is not about Functional vs Imperative or if a particular language does or doesn't have lambda expression.  It is about Denotational vs Operational semantic.   Another word, do you think about your program in term of its execution model or in term of the meaning of the expressions.    <br/>An interesting concept that shows up in Conal's work is that the semantic function is a natural transformation.   Bartosz Milewski does a nice job of explaining what the natural transformation is.    <iframe allowfullscreen="" frameborder="0" height="270" src="https://www.youtube.com/embed/2LJC-XD5Ffo" width="480"></iframe>