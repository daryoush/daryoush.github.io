---
layout: post
title: Your design depends on the glue you have...
date: '2009-02-09T16:27:00.000-08:00'
author: daryoush
tags: 
modified_time: '2009-02-09T20:56:24.360-08:00'
blogger_id: tag:blogger.com,1999:blog-5623577383635787454.post-3452153330557626166
blogger_orig_url: http://onfp.blogspot.com/2009/02/your-design-depends-on-glue-you-have.html
---

The <a href="http://en.wikipedia.org/wiki/Post-it_note">Post-it notes</a> is an interesting case where a glue type created a whole set of products and even programming  <a href="http://vimeo.com/2007411">tutorial</a>!!!   <br /><br />In paper <a href="http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a>, John Huges, has interesting observations:<br /><blockquote><br />It is now generally accepted that modular design is the key to successful programming, .... However, there is a very important point that is often missed. When writing a modular program to solve a problem, one first divides the problem into subproblems, then solves the sub-problems and combines the solutions. <span style="font-weight:bold;">The ways in which one can divide up the original problem depend directly on the ways in which one can glue solutions together. Therefore, to increase ones ability to modularise a problem conceptually, one must provide new kinds of glue in the programming language.<span style="font-style:italic;"></span></span> Complicated scope rules and provision for separate compilation only help with clerical details; they offer no new conceptual tools decomposing problems. <br /><br />One can appreciate the importance of glue by an analogy with carpentry. A chair can be made quite easily by making the parts - seat, legs, back etc. - and sticking them together in the right way. But this depends on an ability to make joints and wood glue. Lacking that ability, the only way to make a chair is to carve it in one piece out of a solid block of wood, a much harder task. This example demonstrates both the enormous power of modularisation and the importance of having the right glue.</blockquote><br /><br />He says:<br /><blockquote><br />To assist modular programming, a language must provide good glue. Functional programming languages provide two new kinds of glue - <a href="http://en.wikipedia.org/wiki/Higher-order_function">higher-order functions</a> and <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">lazy evaluation</a>.</blockquote><br /><br /><br />On higher-order functions he says:<br /><blockquote><br />.....functional languages allow functions which are indivisible in conventional programming languages to be expressed as a combination of parts - a general higher order function and some particular specialising functions. Once defined, such higher order functions allow many operations to be programmed very easily. Whenever a new datatype is defined higher order functions should be written for processing it. This makes manipulating the datatype easy, and also localises knowledge about the details of its representation. The best analogy with conventional programming is with extensible languages  <span style="font-weight:bold;"> - it is as though the programming language can be extended with new control structures whenever desired</span>.</blockquote><br /><br /><br />On Lazy evaluation he says:<br /><blockquote><br />The other new kind of glue that functional languages provide enables whole programs to be glued together. Recall that a complete functional program is just a function from its input to its output. If f and g are such programs, then (g . f ) is a program which, when applied to its input, computes <br /><br />g (f input) <br /><br />The program f computes its output which is used as the input to program g. This might be implemented conventionally by storing the output from f in a temporary file. The problem with this is that the temporary file might occupy so much memory that it is impractical to glue the programs together in this way. Functional languages provide a solution to this problem. The two programs f and g are run together in strict synchronisation. F is only started once g tries to read some input, and only runs for long enough to deliver the output g is trying to read. Then f is suspended and g is run until it tries to read another input. As an added bonus, if g terminates without reading all of f ’s output then f is aborted. F can even be a non-terminating program, producing an infinite amount of output, since it will be terminated forcibly as soon as g is finished. This allows termination conditions to be separated from loop bodies - a powerful modularisation. <br /><br />Since this method of evaluation runs f as little as possible, it is called “lazy evaluation”. It makes it practical to modularise a program as a generator which constructs a large number of possible answers, and a selector which chooses the appropriate one. While some other systems allow programs to be run together in this manner, only functional languages use lazy evaluation uniformly for every function call, allowing any part of a program to be modularised in this way. Lazy evaluation is perhaps the most powerful tool for modularisation in the functional programmer’s repertoire.<br /> </blockquote><br /><br /><br />You can read the whole paper: <a href="http://www.cs.chalmers.se/~rjmh/Papers/whyfp.html">Why Functional Programming Matters</a>