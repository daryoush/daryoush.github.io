---
layout: post
title: Computational Oriented Programming instead of Functional Programming.
date: '2013-07-24T15:58:00.000-07:00'
author: daryoush
tags: 
modified_time: '2013-07-24T15:58:38.122-07:00'
blogger_id: tag:blogger.com,1999:blog-5623577383635787454.post-2849462467036595031
blogger_orig_url: http://onfp.blogspot.com/2013/07/computational-oriented-programming.html
---

IMHO, the term "functional programming" doesn't do justice to the concept that lies behind it. &nbsp; I like to think of it as Computational Oriented Programming. &nbsp;<br /><br />The idea is that you have computations (e.g. &nbsp;state-full computation, non-deterministic, or reactive computation). &nbsp;Each computation is a polymorphic type. &nbsp; You think of your computations as having:<br /><br /><br /><ul><li>Constructors</li><li>Morphism</li><li>Observers</li></ul><div><br /></div><div>Constructors are either when you build a new computation from external types (e.g. putting an integer in a non-deterministic computation -list), or they are higher level combinators that combine two or more of your computation type to a new instance of your computation (concatenating two lists) . &nbsp; Morphisms are when you apply a function to the values in your computation (add one to every element of the list). &nbsp; End result is the same computation but the values have been morphed. &nbsp; The key point in constructors is that the end result is the same computation type that you started with. &nbsp;&nbsp;</div><div><br /></div><div>If you always stay within your computation there is no value to the outside world. &nbsp; So you need observers to export the result of your computation to other forms of computations. &nbsp; &nbsp;Caveat: &nbsp;the term observers here is not the same as the observers that is used in some of the FRP implementation. &nbsp;</div><div><br /></div><div>So when you think of say Functional Reactive Programming you start thinking in a about the constructors and combinators that you would need to express an event processing. &nbsp; &nbsp;Your goal here is to define all the ways one can possibly construct an event handler. &nbsp;A key point in your design must be to define the algebra of combining the FRP computation constructors. &nbsp; The algebra would ensure that any complex combination of the constructors and morphism on the type would be coherent and consistent, otherwise you have a problem in your hand and you need to go back to the drawing board. &nbsp; &nbsp;Once the constructors and combinators are defined a user would be able to define the event handlers. &nbsp; Next you need to define the ways the user would be able to get the result of event handler computations to the outside world. &nbsp; When you are done you have created a new type of computation that due to its polymorphic nature can be used in variety of contexts. &nbsp; That in the essence how you do functional designs.</div>