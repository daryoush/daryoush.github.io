---
layout: post
title: Make friends with Visitors
date: '2008-09-10T14:40:00.000-07:00'
author: daryoush
tags: 
modified_time: '2008-09-10T15:26:04.731-07:00'
blogger_id: tag:blogger.com,1999:blog-5623577383635787454.post-4122192803977210611
blogger_orig_url: http://onfp.blogspot.com/2008/09/make-friends-with-visitors.html
---

A good starting point in understanding functional programming is to understand the difference between <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor</a> and <a href="http://en.wikipedia.org/wiki/Strategy_Pattern">Strategy</a> patterns.  Strategy pattern is what almost all OO programmers  are familiar with.  You have your graphic objects with their draw methods that faithfully draw the object.  From outside the caller has no idea about the underlying implementation.   In this model it is easy to add new objects to the system.  You can add new shapes, just as long as they implement draw method.    The pattern has a weakness in the sense that if you want to add a  new function then it would be difficult.  Let say we need to add a method to calculate the area of a shape, now every object has to be modified to implement the new method.    So you in Strategy pattern you are fixing your class interface but let your data be extensible.<br /><br /><br />Visitor pattern is also an OO pattern but most programmers are not as familiar with it.      The pattern is interesting in the sense that unlike the strategy pattern you fix your classes (say only deal with certain shapes) but let actions be extensible.  In visitor pattern to add a new requirement like calculating perimeter would be easy but adding a new shape would be difficult.   Assigning a new shape will require change to all the existing actions.  The most successful visitor pattern implementation are when you work with a specification where your data is defined but your actions are extensible.  Say for instance  you want to parse XML tree.  The specification of the tree structure is defined but what the application does with the tree is left for the application.    <br /><br />You may think to yourself that if I fix my data types then I would not easily be able to extend my system.  The key is that your data type should not just include primitive types.  It would need to include primitives to modify and compose basic primitives into more complex structure (like tree).  <br /><br /><br /><a href="http://gigamonkeys.com/book/">Peter Seibel</a> does a great job discussing the visitor pattern and its implementation in Java vs Lisp.   The ideas presented in the video is not lisp specific, but rather a different way of thinking about a problem.  Video of his presentation is available <a href="http://video.google.com/videoplay?docid=448441135356213813">online</a>.  Kudos to  Peter for his no-power-point presentation.