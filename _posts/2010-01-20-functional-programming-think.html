---
layout: post
title: Functional Programming Think
date: '2010-01-20T16:46:00.000-08:00'
author: daryoush
tags: 
modified_time: '2010-01-20T17:00:25.549-08:00'
blogger_id: tag:blogger.com,1999:blog-5623577383635787454.post-893072272682797197
blogger_orig_url: http://onfp.blogspot.com/2010/01/functional-programming-think.html
---

It seems that as I am learning more Haskell, I find more nuggets in paper that I had read before.  For instance, John Hughes <a href="http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf">Generalising Monads to Arrows</a> paper has some very interesting insight into functional programming mind set.<br /><br /><br /><blockquote>If this were an isolated case we might simply ignore it. But Swierstra and Duponcheel’s idea is clearly much more widely applicable: to optimise a combinator library, rede ne the combinators to collect static properties of the computations they construct, and then use those static properties to optimise the dynamic computations. If we think of a library as de ning a domain speci c ‘language’, whose constructions are represented as combinators, then Swierstra and Duponcheel’s idea is to implement the language via a combination of a static analysis and an optimised dynamic semantics. We may clearly wish to do this very often indeed. But every time we do, the type of >>= will make it impossible to use a monadic interface!</blockquote><br /><br /><br />And also on Category Theory<br /><br /><blockquote><span style="font-weight:bold;">3.1 On Category Theory</span> <br />Before we do so, we make a short digression on the subject of category theory. The concept of a monad was developed by category theorists long before it eventually found an application in functional programming. Some might find it surprising that something so abstract as category theory should turn out to be useful for something so concrete as programming. <span style="font-weight:bold;">After all, category theory is, in a sense, so abstract as to be rather unsatisfying: it is ‘all definitions and no theorems’ </span>, almost everything turns out to be a category if you look at it long enough, to say something is a category is actually to say very little about it. The same is true of most categorical concepts: they have very many possible instantiations, and so to say that something is, for example, a monad, is to say very little. <span style="font-weight:bold;">This extreme generality is one reason why it is hard for the beginner to develop good intuitions about category theory,</span> but it is hardly surprising: category theory was, after all, developed to be a ‘theory of everything’, a framework into which very many di erent mathematical structures would t. But why should a theory so abstract be of any use for programming? The answer is simple: as computer scientists, we value abstraction! When we design the interface to a software component, we want it to reveal as little as possible about the implementation [think algebra vs calculus]. We want to be able to replace the implementation with many alternatives, many other ‘instances’ of the same ‘concept’. When we design a generic interface to many program libraries, it is even more important that the interface we choose have a wide variety of implementations. It is the very generality of the monad concept which we value so highly, it is because category theory is so abstract that its concepts are so useful for programming.<br />It is hardly surprising, then, that the generalisation of monads that we present below also has a close connection to category theory. But we stress that our purpose is very practical: it is not to ‘implement category theory’, <span style="font weight:bold;">it is to find a more general way to structure combinator libraries </span> It is simply our good fortune that mathematicians have already done much of the work for us.<br /></blockquote>