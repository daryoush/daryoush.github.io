---
layout: post
title: Even more reasons not to use Scala
date: '2013-05-23T22:35:00.000-07:00'
author: daryoush
tags: 
modified_time: '2013-05-23T22:44:49.806-07:00'
blogger_id: tag:blogger.com,1999:blog-5623577383635787454.post-70329521303891610
blogger_orig_url: http://onfp.blogspot.com/2013/05/even-more-reasons-not-to-use-scala.html
---

<div class="tr_bq">In a response to my <a href="http://qr.ae/TH6V4">post</a> to Quora, where I recommended against use of Scala for any serious project, a reader posted <a href="http://qr.ae/pY9IF">this</a>:</div><br /><blockquote class="tr_bq">Let's say you have three functions (f,g, and h) that receive an integer and performs an asynchronous computation, returning Future of Int and you need to chain the three functions together (use the result of one computation as input to the next one). In Scala you'll do:&nbsp;   </blockquote><br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> f(x).flatMap(g(_).flatMap(h(_)))<br /><br /><br /> or with the "for" notation:  <br /><br /><br /> for {  <br />    i &lt;- f(x)  <br />    ii &lt;- g(i)  <br />    iii &lt;-h(ii)  <br />    } yield iii  <br /></code></pre><br />What appears to be a cleaver (or "cute") use of monadic composition is actually seems to be completely&nbsp;misleading. &nbsp; A closer look at the <a href="https://github.com/scala/scala/blob/master/src/library/scala/concurrent/Future.scala#L271">"flatMap" implementation </a>in Future shows that:<br /><br /><br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> def flatMap[S](f: T =&gt; Future[S])(implicit executor: ExecutionContext): Future[S] = {  <br />   val p = Promise[S]()  <br />   onComplete {  <br />    case f: Failure[_] =&gt; p complete f.asInstanceOf[Failure[S]]  <br />    case Success(v) =&gt;  <br />     try {  <br />      f(v).onComplete({  <br />       case f: Failure[_] =&gt; p complete f.asInstanceOf[Failure[S]]  <br />       case Success(v) =&gt; p success v  <br />      })(internalExecutor)  <br />     } catch {  <br />      case NonFatal(t) =&gt; p failure t  <br />     }  <br />   }(executor)  <br />   p.future  <br />  }  <br /></code></pre><br />Another word, your set of futures are no longer running independently and asynchronously (as you would expect in Future) &nbsp;they are composed sequentially in a single Future. &nbsp; If that was your original goal, then you should have composed the functions (in this case f, g, h) and run them in a Future. &nbsp; On the other hand when you do:<br /><blockquote class="tr_bq"><span style="color: #333333; font-family: 'Helvetica Neue', Arial, sans-serif; font-size: 13px;">f(x).flatMap(g(_).flatMap</span><wbr style="color: #333333; font-family: 'Helvetica Neue', Arial, sans-serif; font-size: 13px; margin: 0px; padding: 0px;"></wbr><span style="color: #333333; font-family: 'Helvetica Neue', Arial, sans-serif; font-size: 13px;">(h(_)))</span>&nbsp;</blockquote>you must be thinking that the functions are running in parallel and working on each others output. &nbsp; &nbsp;But it seems (reading the code and not actually done a test, as I don't have the Scala dev environment handy) &nbsp;to me that "g" would not run at all until "f" is finished. &nbsp; Again not what you would expect when you are using Futures.<br /><br /><br />