---
layout: post
title: How glues make a difference
date: '2011-01-16T19:14:00.000-08:00'
author: daryoush
tags: 
modified_time: '2011-02-27T21:04:36.374-08:00'
blogger_id: tag:blogger.com,1999:blog-5623577383635787454.post-3026411359182012172
blogger_orig_url: http://onfp.blogspot.com/2011/01/there-are-folks-that-say-programming.html
---

There are folks that <a href="http://www.paulgraham.com/gh.html">say</a>  programming language does matter.  Some compare it to <a href="http://www.infoq.com/interviews/john-hughes-fp#">glue</a>  that  allow you freedom to build parts from smaller part.  It was hard for me to appreciate this until I saw real examples.  What I have learned is that with right glue your imagination can be liberated to think about possibilities and that is what make the choice of language matter.<br /><br />Lets take the problem of a simple game.  Let say you want to write code to implement the paddle ball.<br /><br /><a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://www.haskell.org/wikiupload/c/ce/PaddleBall.png"><img style="display:block; margin:0px auto 10px; text-align:center;cursor:pointer; cursor:hand;width: 307px; height: 263px;" src="http://www.haskell.org/wikiupload/c/ce/PaddleBall.png" border="0" alt="" /></a><br /><br />If you think Object Oriented about this game.  You see Ball, Paddle, Wall, Score.....  OO techniques would give you a great way to organize your code.  All the code concerning Ball would be encapsulate in the Ball object.   Then the key design decision  you need to make for the Ball, Paddle and Wall  objects is how to detect collision between Ball and Paddle or Wall. Then figure out who does the bounce of the ball.  Is the ball object going to detect the bounce, is the wall telling the ball to bounce...  So you put on your <a href="http://www.evanetics.com/Articles/ar_objectModeling/MilkingAnOOCow.pdf">"Object Think"</a> hat on.   Is it the ball that is detecting the collision, the wall?  Hmmmm   "Trying to Object Think and nothing is happening.  You give up, may be the Collision Manager that watches over all objects is simpler to think about!  Object Think => Let manager decide :)   You also need to worry about user input controlling the Paddle.  Is the code event driven (Inversion of Control)  or is it polling for the inputs....   <br /><br />However you decide to slice the implementation among your object, one thing is going to be true.  You are only thinking about the objects in the paddle game.  At best you may be able to reuse your ideas in similar game.  But the design, if you call what you are doing here as design, is adhoc and has very limited potential.  <br /><br />If you step back and drop your OO thinking and start looking at problem differently you be surprised at how all games are the same and hence can be implemented on common model. <br /><br />If you think of the game as a computation instead of bunch of object then it all looks different.   You ask yourself what is nature of the computation in this game?  One possible answer is to see the game as Interactive (user controls the paddle via key inputs) Animation (graphics that changes over time).   You can further define Animation as time-series (functions of time) graphics.  So now you have three different concepts.   Interactive, Time-Series, and Graphics.  Sum of them would give you the language to express the game while  each one of those ideas can be viewed by itself.   What would Interactive computation need to have?  What would Time-Series computation need?   and finally what would Graphics packages need to have to be fully expressive.  In all three cases you are asking yourself the compositional needs of each of your concern and define a language for it.   For instance, on the graphics you will define a language to have simple shapes, complex shapes as and/or/xor of simple shapes, transposition of shapes..... Most likely you will find an existing library that defines appropriate DSL for each of the concerns of our game.   <br /><br />Ideally you want a programming language  that allows you to compose notions (in this case interactive, animation, and graphics) in one grand notion such that you can express your game in.    So you say key x causes mouse to go left, or right, ball travels at some velocity (speed and direction), when the ball hits wall or paddle it bounces ( you defined a bounce as change in the direction of velocity).   If ball passes the edge it is outside, game is over..  You are done.   It is all basically the description of the game.   Even better, you can reuse the same notions and may be describe the car racing game.   If the approach interest you, you can get more details in <a href="http://plucky.cs.yale.edu/soe/">SOE</a>.<br /><br />All of sudden in the new perspective you have something that is truly re-usable.   You may be able to implement this in Java too.   But the key idea, as we saw here,  is that the standard OO techniques leads you to a dead end, you are worrying about non issues and the result has limited potential.  Furthermore, where your native language doesn't give you the compositional capabilities you need, you be forced to try to figure out ways to implement them.   It may be verbose, ugly and hard to understand which is why most people end up with mainstream usage model of the language.  <br /><br />So that is how the language does matter.   Glues make it all possible to build powerful abstraction.